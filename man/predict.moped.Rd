% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/predict.R
\name{predict.moped}
\alias{predict.moped}
\title{Predicting the density or probability of an observation based on moped
density estimate.}
\usage{
\method{predict}{moped}(
  fit,
  X = NULL,
  K = NULL,
  variables = 1:fit$Nv,
  bounds = NULL,
  type = "density",
  normalise = T,
  nodes = 100,
  parallel = F,
  ncores = NULL,
  mps = 5000
)
}
\arguments{
\item{fit}{\code{moped} type variable. Outputted from \code{moped()}.}

\item{X}{An optional data frame in which to look for variables with which
to estimate density values. Must contain column names matching variables in
the \code{moped} object. If \code{NULL} (the default) then generates a \code{nodes}^\code{fit$Nv}
grid with density values.}

\item{K}{Integer vector of max polynomial order of approximation on each
variable. Must be less than or equal to the maximum MPO K specified in
\code{moped()}. The default is the \code{opt_mpo} or \code{KMax} (if \code{opt_mpo = NULL}) specified
in \code{fit}.}

\item{variables}{Integer vector or character string of variable names. The
\code{moped} position or column name of the variable(s) to be predicted from
\code{moped} object. The default is \code{1:fit$Nv}.}

\item{bounds}{An optional data frame specifying the limits to be used on bounded space.
Should be an array of 2 x number of variables with each column having the
lower and upper limit.}

\item{type}{string equal to \code{"density"} (default) or \code{"distribution"}. If
\code{type = "density"} density values are estimated. If \code{type = "distribution"}
cumulative distribution function probabilities are estimated.}

\item{normalise}{Logical that if \code{TRUE} (the default), scales density estimate
to correct for any estimated negative values.}

\item{nodes}{Integer vector that corresponds to the number of grid points per
dimension when \code{X = NULL} and a grid is calculated.}

\item{parallel}{Logical that if \code{TRUE} uses the \code{parallel} package to simulate
values using parallel computing.}

\item{ncores}{Integer vector that determines the number of cores used in parallel computing.}

\item{mps}{Integer vector that places a limit on maximum number of probabilities
calculated at a time. The default is 5000.}
}
\value{
\code{predict.moped()} returns a data frame with estimated density/probability values.
}
\description{
\code{predict.moped()} is used to predict density and probabilities for a set of
observations. When constructing partially joint density, sample and variables must be used
together. X must be a data frame and its variable length must equal to
the length in var.
}
\examples{
Data_full <- ISLR::Wage
Data <- Data_full \%>\%
select(age, education, jobclass,wage)

# Convert Categorical Data to Continuous Data
Data_x <- make.cont(Data, catvar = 2:3)

# Fitting multivariate orthogonal polynomial based
# density estimation function
# Requires a data frame of bounds to fit on data.
bounds <- data.frame(
age  = c(17,80),
education = c(0,1),
jobclass = c(0,1),
wage = c(0,350)
)

# Fitting the Data
Fit <- moped(
Data_x,
K=10,
Distrib = rep("Uniform", 4),
bounds = bounds,
variance = T,
recurrence = F,
parallel = F,
ncores = NULL,
mpo = T
)

# Define the observation which the probability is desired
x0 <- Data_x[1,]
pred <- predict(Fit, K= 7, X = x0)

# Predicting Marginal Density for a set of observations
# When constructing partially joint density, X and variables must be used together.
pred <- predict(Fit, K= 7, X= Data_x[,3:4] , variables =c("jobclass", "wage"))
pred <- predict(Fit, K= 7, X= data.frame(wage=Data_x$wage) , variables =c("wage"))
pred <- predict(Fit, K= 7, X= data.frame(wage=Data_x$wage) , variables =4 )
pred <- predict(Fit, K= c(2,7), X= Data_x[,3:4] , variables =c("jobclass","wage"))

# Plotting marginal density
predict(Fit, K= 7, variables =4) \%>\%
ggplot(aes(x=wage,y=Density)) +
geom_line()

# Plotting bivariate density plot
predict(Fit, K= c(2,7), variables =3:4) \%>\%
ggplot(aes(x=jobclass,y=wage,fill=Density)) +
geom_tile() +
scale_fill_distiller(palette = "Spectral")
}
